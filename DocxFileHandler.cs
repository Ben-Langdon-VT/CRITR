using System;
using System.Collections.Generic;
using System.IO;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using DocumentFormat.OpenXml;


/*
    Important Context: Initial Code generated by chatgpt, i further broke it down into pieces to be more useful for potentially other tasks/ template styles

    Both C# Documentation and ChatGPT recommended using the using(blah) {} style instead of what I was doing which was having files be a class property. The explanation GPT gave
    Was that file streams implement IDisposable, which holds unmanaged resources or file handles that need to be cleaned up when not using object.
    There is probs a better way to do this than to constantly be opening and closing the word document though lol, more of a design for people who are doing one big edit than many small ones.

    Uses memory stream as a placeholder to hold template file in memory instead of saving it

    GPT Output: Style kind of weird that all functions are voids and do not return objects, but its what ChatGPT did so i just went with it when breaking loop into pieces

    output uses Chunk feature of openxml, creates a new chunk part with a specific id which is added to the outer document object, then fills chunk with tempfile and adds 
    a new chunk object at the end of the document body


*/
namespace CRITR
{
    public class DocxFileHandler
    {
        private void CreateWordprocessingDocument(string filepath)
        {
            // Create a document by supplying the filepath. 
            using (WordprocessingDocument wordDocument =
                WordprocessingDocument.Create(filepath, WordprocessingDocumentType.Document))
            {
                // Add a main document part. 
                MainDocumentPart mainPart = wordDocument.AddMainDocumentPart();

                // Create the document structure and add some text.
                mainPart.Document = new Document();
                Body body = mainPart.Document.AppendChild(new Body());
            }
        }

        public void AddSimpleParagraph(string filePath, string text)
        {
            using (WordprocessingDocument tempDoc = WordprocessingDocument.Open(filePath, true))
            {
                MainDocumentPart? mainPart = tempDoc.MainDocumentPart;
                //Handle weird exceptions so that I dont get the yellow errors
                if (mainPart == null)
                {
                    throw new FileLoadException(String.Format("File {0} does not contain MainDocumentPart element, file either not docx or corrupt", filePath));
                }

                Body? body = mainPart.Document.Body;

                if (body == null)
                {
                    throw new FileLoadException(String.Format("File {0} does not contain MainDocumentPart.Document.Body element, file either not docx or corrupt", filePath));
                }

                Paragraph para = body.AppendChild(new Paragraph());
                Run run = para.AppendChild(new Run());
                run.AppendChild(new Text(text));
            }
        }
        public void ReplaceAppendTemplate(string blankTemplatePath, string outputPath, Dictionary<string, string> entry, string imagePath = "")
        {
            if (!File.Exists(blankTemplatePath))
            {
                throw new FileNotFoundException(String.Format("No template docx file found at {0}", blankTemplatePath));
            }
            if (!File.Exists(outputPath))
            {
                CreateWordprocessingDocument(outputPath);
            }
            //Standard using to avoid memory leaks from unmanaged resources/other Idisplosable file stuff
            using (MemoryStream filledTemplate = new MemoryStream())
            {
                //Create Fresh template copy from blankTemplate
                File.OpenRead(blankTemplatePath).CopyTo(filledTemplate);

                //Reset to point at begging of file new template file
                filledTemplate.Position = 0;
                //Standard using to avoid memory leaks from unmanaged resources/other Idisplosable file stuff
                using (WordprocessingDocument tempDoc = WordprocessingDocument.Open(filledTemplate, true))
                {
                    ReplaceTextInWordDocLoop(tempDoc, blankTemplatePath, entry, imagePath);
                }


                // Append the content of the temporary document to the output document.
                AppendMemoryTemplate(filledTemplate, outputPath);

            }
        }

        private void ReplaceTextInWordDocLoop(WordprocessingDocument tempDoc, String blankTemplatePath, Dictionary<String, String> entry, String imagePath = "")
        {

            MainDocumentPart? mainPart = tempDoc.MainDocumentPart;

            //Handle weird exceptions so that I dont get the yellow errors
            if (mainPart == null)
            {
                throw new FileLoadException(String.Format("File {0} does not contain MainDocumentPart element, file either not docx or corrupt", blankTemplatePath));
            }

            Body? body = mainPart.Document.Body;

            if (body == null)
            {
                throw new FileLoadException(String.Format("File {0} does not contain MainDocumentPart.Document.Body element, file either not docx or corrupt", blankTemplatePath));
            }

            // Replace the placeholders with the entry values.
            ReplaceTextInWordDocBody(body, entry);

            //delete old Image, add new image, replace image BLIP code in xml
            if (imagePath != "")
            {
                ReplaceFirstImage(mainPart, imagePath);
            }


            // Save the changes to the temporary document.
            mainPart.Document.Save();
        }


        private void ReplaceFirstImage(MainDocumentPart mainPart, String imagePath)
        {
            ImagePart? imagePart = mainPart.ImageParts.LastOrDefault();
            if (imagePart != null)
            {
                mainPart.DeletePart(imagePart);

                ImagePart newImagePart = mainPart.AddImagePart(ImagePartType.Jpeg);

                using (FileStream stream = new FileStream(imagePath, FileMode.Open))
                {
                    newImagePart.FeedData(stream);
                }

                var element = mainPart.Document.Descendants<DocumentFormat.OpenXml.Drawing.Blip>().Last();
                element.Embed = mainPart.GetIdOfPart(newImagePart);

                mainPart.Document.Save();
            }
        }
        //Loops through each text element in a document body and replaces keywords
        private void ReplaceTextInWordDocBody(Body body, Dictionary<String, String> entry)
        {

            foreach (var text in body.Descendants<Text>())
            {
                foreach (String key in entry.Keys)
                {

                    String rString = "{" + key + "}";
                    if (text.Text.Contains(rString))
                    {
                        text.Text = text.Text.Replace(rString, entry[key]);
                    }
                }
            }
        }


        private void AppendMemoryTemplate(MemoryStream template, string outputPath)
        {
            //Standard using to avoid memory leaks from unmanaged resources/other Idisplosable file stuff
            using (WordprocessingDocument outputDoc = WordprocessingDocument.Open(outputPath, true))
            {
                MainDocumentPart? mainPart = outputDoc.MainDocumentPart;

                //Handle weird exceptions so that I dont get the yellow errors
                if (mainPart == null)
                {
                    throw new FileLoadException(String.Format("File {0} does not contain MainDocumentPart element, file either not docx or corrupt", outputPath));
                }

                Body? body = mainPart.Document.Body;

                if (body == null)
                {
                    throw new FileLoadException(String.Format("File {0} does not contain MainDocumentPart.Document.Body element, file either not docx or corrupt", outputPath));
                }


                template.Position = 0;

                // Create a new AlternativeFormatImportPart linked to the temporary document.
                string altChunkId = "AltChunkId" + Guid.NewGuid();
                AlternativeFormatImportPart chunk = mainPart.AddAlternativeFormatImportPart(AlternativeFormatImportPartType.WordprocessingML, altChunkId);

                // Feed the content of the temporary document into the AlternativeFormatImportPart.
                chunk.FeedData(template);

                // Create an AltChunk element linked to the AlternativeFormatImportPart and add it to the main document part.
                AltChunk altChunk = new AltChunk();
                altChunk.Id = altChunkId;
                body.Append(altChunk);

                // Save the changes to the output document.
                mainPart.Document.Save();
            }
        }
    }
}